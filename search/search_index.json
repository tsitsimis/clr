{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ConstrainedLR","text":"<p>constrainedlr is a drop-in replacement of sklearn's <code>linear_model.LinearRegression</code>, <code>linear_model.RidgeRegression</code>, <code>linear_model.Elasticnet</code>, <code>linear_model.Lasso</code>, with the additional ability to add coefficient constraints</p> <p>Source Code: https://github.com/tsitsimis/constrainedlr.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install constrainedlr\n\n---&gt; 100%\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#sign-constraints","title":"Sign constraints","text":"<p>Apply constraints on the signs of one or more coefficients of the model.</p> <pre><code>from sklearn.datasets import load_diabetes\nfrom constrainedlr.model import ConstrainedLinearRegression\n# Load dataset\ndataset = load_diabetes()\nX = dataset[\"data\"]\ny = dataset[\"target\"]\n# Instantiate Constrained Linear Regression model \nmodel = ConstrainedLinearRegression(fit_intercept=True)\n# Fit model and constraint the sign of the 1st and 3rd coefficient\n# Coefficients are selected based on their index (zero-based) in the dataset\nsign_constraints = {\n0: 1,  # Coefficient of 1st feature must be positive\n2: -1,  # Coefficient of 3rd feature must be negative\n3: 0,  # Coefficient of 4th feature has no sign constraint (this is optional)\n# The remaining coefficients are not specified and by default have no sign constraints \n}\nmodel.fit(X, y, coefficients_sign_constraints=sign_constraints)\nprint(model.coef_)\n</code></pre>"},{"location":"#range-constraints","title":"Range constraints","text":"<p>Apply constraints on the value of one or more coefficients. It enables to define a lower and/or upper bound of each coeficient.</p> <pre><code>model = ConstrainedLinearRegression(fit_intercept=True)\n# Fit model and constraint the sign of the 1st and 3rd coefficient\n# Coefficients are selected based on their index (zero-based) in the dataset\nrange_constraints = {\n0: {\"lower\": 2},  # Coefficient of 1st feature must be 2 or higher\n2: {\"upper\": 10},  # Coefficient of 3rd feature can not be larger than 10\n3: {\"lower\": 3, \"upper\": 4},  # Coefficient of 4th feature must have a value between 3 and 4\n# The remaining coefficients are not specified and by default have no range constraints \n}\nmodel.fit(X, y, coefficients_range_constraints=range_constraints)\nprint(model.coef_)\n</code></pre>"},{"location":"API/","title":"API","text":""},{"location":"API/#src.constrainedlr.model.ConstrainedLinearRegression","title":"<code>ConstrainedLinearRegression</code>","text":"<p>         Bases: <code>BaseEstimator</code>, <code>RegressorMixin</code></p> Source code in <code>src\\constrainedlr\\model.py</code> <pre><code>class ConstrainedLinearRegression(BaseEstimator, RegressorMixin):\ndef __init__(self, fit_intercept: bool = True, alpha: float = 0.0):\n\"\"\"\n        Least squares Linear Regression with optional constraints on its coefficients/weights.\n        ConstrainedLinearRegression fits a linear model with coefficients w = (w1, \u2026, wp) to minimize the residual\n        sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation,\n        while at the same time imposing constraints on the signs and values of the coefficients.\n        Args:\n            fit_intercept:\n                Whether to calculate the intercept for this model.\n            alpha:\n                Constant that multiplies the L2 penalty term, controlling regularization strength.\n                alpha must be a non-negative float i.e. in [0, inf).\n        Attributes:\n            coef_:\n                Weight vector of shape (n_features,).\n            intercept_:\n                Independent/constant term in regression model. Set to None if fit_intercept = False.\n        \"\"\"\nself.fit_intercept = fit_intercept\nself.coef_ = None\nself.intercept_ = None\nself.alpha = alpha\ndef fit(\nself,\nX: Union[np.ndarray, pd.DataFrame],\ny: np.ndarray,\nsample_weight: np.ndarray = None,\ncoefficients_sign_constraints: dict = {},\ncoefficients_range_constraints: dict = {},\nintercept_sign_constraint: int = 0,\ncoefficients_sum_constraint: float = None,\n) -&gt; \"ConstrainedLinearRegression\":\n\"\"\"\n        Fit linear model with constraints.\n        Args:\n            X:\n                Training data of shape (n_samples, n_features).\n            y:\n                Target values of shape (n_samples,).\n            sample_weight:\n                Individual weights of shape (n_samples,) for each sample.\n            coefficients_sign_constraints:\n                Dictionary with sign constraints. Keys must be integers specifying the location of the corresponding feature\n                in the columns in the dataset. Values must take the values: -1, 0, 1 indicating negative,\n                unconstrained and positive sign respectively. Any column that is not present in the\n                dictionary will default to 0.\n            coefficients_range_constraints:\n                Dictionary of the form: `{column_index: {\"lower\": &lt;float&gt;, \"upper\": &lt;float&gt;}}`.\n                Eiter both or one of lower or upper bounds can be specified. If a column index is not specified,\n                the coefficient remains unconstrained. Only one of `features_sign_constraints` or `coefficients_range_constraints`\n                can be provided.\n            intercept_sign_constraint:\n                Indicates the sign of intercept, if present, and must take the values: -1, 0, 1.\n            coefficients_sum_constraint:\n                Constraints the sum of all coefficients plus intercept (if present).\n        Returns:\n            Fitted Estimator.\n        \"\"\"\nX, y = check_X_y(X, y)\nvalidate_coefficients_sign_constraints(coefficients_sign_constraints, X)\nvalidate_coefficients_range_constraints(coefficients_range_constraints, X)\nif len(coefficients_sign_constraints) &gt; 0 and len(coefficients_range_constraints) &gt; 0:\nraise ValueError(\n\"Only one of `features_sign_constraints` or `coefficients_range_constraints` can be provided.\"\n)\nif np.ndim(y) == 1:\ny = y.reshape(-1, 1)\nn_samples, n_features = X.shape\n# Augment features to fit intercept\nif self.fit_intercept:\nX = np.hstack([X, np.ones(n_samples).reshape(-1, 1)])\ndim = X.shape[1]\n# Weight matrix\nif sample_weight is None:\nW = np.eye(n_samples)\nelse:\nW = np.diag(sample_weight)\n# Quadratic program\nP = X.T.dot(W).dot(X) + self.alpha * np.eye(dim)\nP = matrix(P)\nq = (-y.T.dot(W).dot(X)).T\nq = matrix(q)\nG, h = None, None\nfeatures_sign_constraints_full = {feature: 0 for feature in range(n_features)}\nfeatures_sign_constraints_full.update(coefficients_sign_constraints)\ndiag_values = list(features_sign_constraints_full.values())\nif self.fit_intercept:\ndiag_values.append(intercept_sign_constraint)\nG = -1.0 * np.diag(diag_values)  # Negate since cvxopt by convention accepts inequalities of the form Gx &lt;= h\nG = matrix(G)\nh = np.zeros(dim)\nh = matrix(h)\nif len(coefficients_range_constraints) &gt; 0:\ncoefficients_upper_bound_constraints = {\nk: v for k, v in coefficients_range_constraints.items() if \"upper\" in v\n}\nG_upper = np.zeros((len(coefficients_upper_bound_constraints), dim))\nfor i, feature in enumerate(coefficients_upper_bound_constraints.keys()):\nG_upper[i, feature] = 1\nh_upper = np.array([v[\"upper\"] for k, v in coefficients_upper_bound_constraints.items()])\ncoefficients_lower_bound_constraints = {\nk: v for k, v in coefficients_range_constraints.items() if \"lower\" in v\n}\nG_lower = np.zeros((len(coefficients_lower_bound_constraints), dim))\nfor i, feature in enumerate(coefficients_lower_bound_constraints.keys()):\nG_lower[i, feature] = -1\nh_lower = -1.0 * np.array([v[\"lower\"] for k, v in coefficients_lower_bound_constraints.items()])\nG = np.concatenate([G_upper, G_lower], axis=0).astype(\"float\")\nG = matrix(G)\nh = np.concatenate([h_upper, h_lower])\nh = matrix(h)\nA, b = None, None\nif coefficients_sum_constraint:\nA = np.ones(dim).astype(\"float\")\nA = A.reshape(1, -1)\nA = matrix(A)\nb = np.array([coefficients_sum_constraint]).astype(\"float\")\nb = matrix(b)\nsolvers.options[\"show_progress\"] = False\nsolver = solvers.qp(P=P, q=q, G=G, h=h, A=A, b=b)\nweights = np.array(solver[\"x\"]).flatten()\nif self.fit_intercept:\nself.coef_ = weights[0:-1]\nself.intercept_ = weights[-1]\nelse:\nself.coef_ = weights\nreturn self\ndef predict(self, X: Union[np.ndarray, pd.DataFrame]) -&gt; np.ndarray:\n\"\"\"\n        Predict using the linear model.\n        Parameters:\n            X:\n                Samples of shape (n_samples, n_features).\n        Returns:\n            Predicted values of shape (n_samples,).\n        \"\"\"\ncheck_is_fitted(self)\nX = check_array(X)\nn_samples = X.shape[0]\n# Augment features for intercept\nif self.fit_intercept:\nX = np.hstack([X, np.ones(n_samples).reshape(-1, 1)])\nweights = np.concatenate([self.coef_, [self.intercept_]])\nelse:\nweights = self.coef_\ny_pred = X.dot(weights)\nreturn y_pred\n</code></pre>"},{"location":"API/#src.constrainedlr.model.ConstrainedLinearRegression.__init__","title":"<code>__init__(fit_intercept=True, alpha=0.0)</code>","text":"<p>Least squares Linear Regression with optional constraints on its coefficients/weights.</p> <p>ConstrainedLinearRegression fits a linear model with coefficients w = (w1, \u2026, wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation, while at the same time imposing constraints on the signs and values of the coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>fit_intercept</code> <code>bool</code> <p>Whether to calculate the intercept for this model.</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Constant that multiplies the L2 penalty term, controlling regularization strength. alpha must be a non-negative float i.e. in [0, inf).</p> <code>0.0</code> <p>Attributes:</p> Name Type Description <code>coef_</code> <p>Weight vector of shape (n_features,).</p> <code>intercept_</code> <p>Independent/constant term in regression model. Set to None if fit_intercept = False.</p> Source code in <code>src\\constrainedlr\\model.py</code> <pre><code>def __init__(self, fit_intercept: bool = True, alpha: float = 0.0):\n\"\"\"\n    Least squares Linear Regression with optional constraints on its coefficients/weights.\n    ConstrainedLinearRegression fits a linear model with coefficients w = (w1, \u2026, wp) to minimize the residual\n    sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation,\n    while at the same time imposing constraints on the signs and values of the coefficients.\n    Args:\n        fit_intercept:\n            Whether to calculate the intercept for this model.\n        alpha:\n            Constant that multiplies the L2 penalty term, controlling regularization strength.\n            alpha must be a non-negative float i.e. in [0, inf).\n    Attributes:\n        coef_:\n            Weight vector of shape (n_features,).\n        intercept_:\n            Independent/constant term in regression model. Set to None if fit_intercept = False.\n    \"\"\"\nself.fit_intercept = fit_intercept\nself.coef_ = None\nself.intercept_ = None\nself.alpha = alpha\n</code></pre>"},{"location":"API/#src.constrainedlr.model.ConstrainedLinearRegression.fit","title":"<code>fit(X, y, sample_weight=None, coefficients_sign_constraints={}, coefficients_range_constraints={}, intercept_sign_constraint=0, coefficients_sum_constraint=None)</code>","text":"<p>Fit linear model with constraints.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[np.ndarray, pd.DataFrame]</code> <p>Training data of shape (n_samples, n_features).</p> required <code>y</code> <code>np.ndarray</code> <p>Target values of shape (n_samples,).</p> required <code>sample_weight</code> <code>np.ndarray</code> <p>Individual weights of shape (n_samples,) for each sample.</p> <code>None</code> <code>coefficients_sign_constraints</code> <code>dict</code> <p>Dictionary with sign constraints. Keys must be integers specifying the location of the corresponding feature in the columns in the dataset. Values must take the values: -1, 0, 1 indicating negative, unconstrained and positive sign respectively. Any column that is not present in the dictionary will default to 0.</p> <code>{}</code> <code>coefficients_range_constraints</code> <code>dict</code> <p>Dictionary of the form: <code>{column_index: {\"lower\": &lt;float&gt;, \"upper\": &lt;float&gt;}}</code>. Eiter both or one of lower or upper bounds can be specified. If a column index is not specified, the coefficient remains unconstrained. Only one of <code>features_sign_constraints</code> or <code>coefficients_range_constraints</code> can be provided.</p> <code>{}</code> <code>intercept_sign_constraint</code> <code>int</code> <p>Indicates the sign of intercept, if present, and must take the values: -1, 0, 1.</p> <code>0</code> <code>coefficients_sum_constraint</code> <code>float</code> <p>Constraints the sum of all coefficients plus intercept (if present).</p> <code>None</code> <p>Returns:</p> Type Description <code>ConstrainedLinearRegression</code> <p>Fitted Estimator.</p> Source code in <code>src\\constrainedlr\\model.py</code> <pre><code>def fit(\nself,\nX: Union[np.ndarray, pd.DataFrame],\ny: np.ndarray,\nsample_weight: np.ndarray = None,\ncoefficients_sign_constraints: dict = {},\ncoefficients_range_constraints: dict = {},\nintercept_sign_constraint: int = 0,\ncoefficients_sum_constraint: float = None,\n) -&gt; \"ConstrainedLinearRegression\":\n\"\"\"\n    Fit linear model with constraints.\n    Args:\n        X:\n            Training data of shape (n_samples, n_features).\n        y:\n            Target values of shape (n_samples,).\n        sample_weight:\n            Individual weights of shape (n_samples,) for each sample.\n        coefficients_sign_constraints:\n            Dictionary with sign constraints. Keys must be integers specifying the location of the corresponding feature\n            in the columns in the dataset. Values must take the values: -1, 0, 1 indicating negative,\n            unconstrained and positive sign respectively. Any column that is not present in the\n            dictionary will default to 0.\n        coefficients_range_constraints:\n            Dictionary of the form: `{column_index: {\"lower\": &lt;float&gt;, \"upper\": &lt;float&gt;}}`.\n            Eiter both or one of lower or upper bounds can be specified. If a column index is not specified,\n            the coefficient remains unconstrained. Only one of `features_sign_constraints` or `coefficients_range_constraints`\n            can be provided.\n        intercept_sign_constraint:\n            Indicates the sign of intercept, if present, and must take the values: -1, 0, 1.\n        coefficients_sum_constraint:\n            Constraints the sum of all coefficients plus intercept (if present).\n    Returns:\n        Fitted Estimator.\n    \"\"\"\nX, y = check_X_y(X, y)\nvalidate_coefficients_sign_constraints(coefficients_sign_constraints, X)\nvalidate_coefficients_range_constraints(coefficients_range_constraints, X)\nif len(coefficients_sign_constraints) &gt; 0 and len(coefficients_range_constraints) &gt; 0:\nraise ValueError(\n\"Only one of `features_sign_constraints` or `coefficients_range_constraints` can be provided.\"\n)\nif np.ndim(y) == 1:\ny = y.reshape(-1, 1)\nn_samples, n_features = X.shape\n# Augment features to fit intercept\nif self.fit_intercept:\nX = np.hstack([X, np.ones(n_samples).reshape(-1, 1)])\ndim = X.shape[1]\n# Weight matrix\nif sample_weight is None:\nW = np.eye(n_samples)\nelse:\nW = np.diag(sample_weight)\n# Quadratic program\nP = X.T.dot(W).dot(X) + self.alpha * np.eye(dim)\nP = matrix(P)\nq = (-y.T.dot(W).dot(X)).T\nq = matrix(q)\nG, h = None, None\nfeatures_sign_constraints_full = {feature: 0 for feature in range(n_features)}\nfeatures_sign_constraints_full.update(coefficients_sign_constraints)\ndiag_values = list(features_sign_constraints_full.values())\nif self.fit_intercept:\ndiag_values.append(intercept_sign_constraint)\nG = -1.0 * np.diag(diag_values)  # Negate since cvxopt by convention accepts inequalities of the form Gx &lt;= h\nG = matrix(G)\nh = np.zeros(dim)\nh = matrix(h)\nif len(coefficients_range_constraints) &gt; 0:\ncoefficients_upper_bound_constraints = {\nk: v for k, v in coefficients_range_constraints.items() if \"upper\" in v\n}\nG_upper = np.zeros((len(coefficients_upper_bound_constraints), dim))\nfor i, feature in enumerate(coefficients_upper_bound_constraints.keys()):\nG_upper[i, feature] = 1\nh_upper = np.array([v[\"upper\"] for k, v in coefficients_upper_bound_constraints.items()])\ncoefficients_lower_bound_constraints = {\nk: v for k, v in coefficients_range_constraints.items() if \"lower\" in v\n}\nG_lower = np.zeros((len(coefficients_lower_bound_constraints), dim))\nfor i, feature in enumerate(coefficients_lower_bound_constraints.keys()):\nG_lower[i, feature] = -1\nh_lower = -1.0 * np.array([v[\"lower\"] for k, v in coefficients_lower_bound_constraints.items()])\nG = np.concatenate([G_upper, G_lower], axis=0).astype(\"float\")\nG = matrix(G)\nh = np.concatenate([h_upper, h_lower])\nh = matrix(h)\nA, b = None, None\nif coefficients_sum_constraint:\nA = np.ones(dim).astype(\"float\")\nA = A.reshape(1, -1)\nA = matrix(A)\nb = np.array([coefficients_sum_constraint]).astype(\"float\")\nb = matrix(b)\nsolvers.options[\"show_progress\"] = False\nsolver = solvers.qp(P=P, q=q, G=G, h=h, A=A, b=b)\nweights = np.array(solver[\"x\"]).flatten()\nif self.fit_intercept:\nself.coef_ = weights[0:-1]\nself.intercept_ = weights[-1]\nelse:\nself.coef_ = weights\nreturn self\n</code></pre>"},{"location":"API/#src.constrainedlr.model.ConstrainedLinearRegression.predict","title":"<code>predict(X)</code>","text":"<p>Predict using the linear model.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[np.ndarray, pd.DataFrame]</code> <p>Samples of shape (n_samples, n_features).</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Predicted values of shape (n_samples,).</p> Source code in <code>src\\constrainedlr\\model.py</code> <pre><code>def predict(self, X: Union[np.ndarray, pd.DataFrame]) -&gt; np.ndarray:\n\"\"\"\n    Predict using the linear model.\n    Parameters:\n        X:\n            Samples of shape (n_samples, n_features).\n    Returns:\n        Predicted values of shape (n_samples,).\n    \"\"\"\ncheck_is_fitted(self)\nX = check_array(X)\nn_samples = X.shape[0]\n# Augment features for intercept\nif self.fit_intercept:\nX = np.hstack([X, np.ones(n_samples).reshape(-1, 1)])\nweights = np.concatenate([self.coef_, [self.intercept_]])\nelse:\nweights = self.coef_\ny_pred = X.dot(weights)\nreturn y_pred\n</code></pre>"},{"location":"licence/","title":"Licence","text":"<p>MIT</p>"}]}